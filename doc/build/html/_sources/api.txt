API
===

.. highlight:: cpp

.. index:: FaceRecognizer

FaceRecognizer
--------------

.. ocv:class:: FaceRecognizer

All face recognition models in libfacerec are derived from the abstract base 
class :ocv:class:`FaceRecognizer`, which provides a unified access to all face 
recongition algorithms. ::

  namespace cv {

  class FaceRecognizer {
  public:

      //! virtual destructor
      virtual ~FaceRecognizer() {}

      // Trains a FaceRecognizer.
      virtual void train(InputArray src, InputArray labels) = 0;

      // Gets a prediction from a FaceRecognizer.
      virtual int predict(InputArray src) const = 0;

      // Serializes this object to a given filename.
      virtual void save(const string& filename) const;

      // Deserializes this object from a given filename.
      virtual void load(const string& filename);

      // Serializes this object to a given cv::FileStorage.
      virtual void save(FileStorage& fs) const = 0;

      // Deserializes this object from a given cv::FileStorage.
      virtual void load(const FileStorage& fs) = 0;
  };


FaceRecognizer::~FaceRecognizer
*******************************

.. ocv:function:: FaceRecognizer::~FaceRecognizer()

The destructor of the base class is declared as virtual. So, it is safe to 
write the following code: 

.. code-block:: cpp

    FaceRecongnizer* model;
    if(use_eigenfaces)
        model = new Eigenfaces(... /* Eigenfaces params */);
    else
        model = new LBPH(... /* LBP Histogram params */);
    ...
    delete model;
  
FaceRecognizer::train
*********************

Trains a FaceRecognizer with given data and associated labels.

.. ocv:function:: void FaceRecognizer::train(InputArray src, InputArray labels)

Every model subclassing :ocv:class:`FaceRecognizer` must be able to work with 
image data (``src``) given as a ``vector<Mat>``. This is important, because it's 
impossible to make general assumptions about the dimensionality of input 
samples. The Local Binary Patterns for example process 2D images, while 
Eigenfaces and Fisherfaces method reshape all images in ``src`` to a data 
matrix.

The associated labels in ``labels`` have to be given either in a 1D vector (a 
row or a column) of ``CV_32SC1`` or a ``vector<int>``.

The following example shows how to learn a Fisherfaces model with libfacerec:

.. code-block:: cpp

  // holds images and labels
  vector<Mat> images;
  vector<int> labels;
  // images for first person
  images.push_back(imread("person0/0.jpg", CV_LOAD_IMAGE_GRAYSCALE)); labels.push_back(0);
  images.push_back(imread("person0/1.jpg", CV_LOAD_IMAGE_GRAYSCALE)); labels.push_back(0);
  images.push_back(imread("person0/2.jpg", CV_LOAD_IMAGE_GRAYSCALE)); labels.push_back(0);
  // images for second person
  images.push_back(imread("person1/0.jpg", CV_LOAD_IMAGE_GRAYSCALE)); labels.push_back(1);
  images.push_back(imread("person1/1.jpg", CV_LOAD_IMAGE_GRAYSCALE)); labels.push_back(1);
  images.push_back(imread("person1/2.jpg", CV_LOAD_IMAGE_GRAYSCALE)); labels.push_back(1);
  // create a new Fisherfaces model
  Fisherfaces model(images, labels);
  // ... or you could do
  ///Fisherfaces model;
  ///model.train(images,labels);

FaceRecognizer::predict
***********************

.. ocv:function:: int FaceRecognizer::predict(InputArray src) const

Predicts the label for a given query image in ``src``. 

The suffix ``const`` means that prediction does not affect the internal model 
state, so the method can be safely called from within different threads.

The following example shows how to get a prediction from a trained model:

.. code-block:: cpp

  Mat mQuery = imread("person1/3.jpg", CV_LOAD_IMAGE_GRAYSCALE);
  int predicted = model.predict(mQuery);

FaceRecognizer::save
********************

Saves a :ocv:class:`FaceRecognizer` and its model state.

.. ocv:function:: void FaceRecognizer::save(const string& filename) const
.. ocv:function:: void FaceRecognizer::save(FileStorage& fs) const


Every :ocv:class:`FaceRecognizer` has to overwrite ``FaceRecognizer::save(FileStorage& fs)``
to save the model state. ``FaceRecognizer::save(FileStorage& fs)`` is then 
called by ``FaceRecognizer::save(const string& filename)``, to ease saving a 
model.

The suffix ``const`` means that prediction does not affect the internal model 
state, so the method can be safely called from within different threads.


FaceRecognizer::load
********************

Loads a :ocv:class:`FaceRecognizer` and its model state.

.. ocv:function:: void FaceRecognizer::load(const string& filename)
.. ocv:function:: void FaceRecognizer::load(FileStorage& fs)

Loads a persisted model and state from a given XML or YAML file . Every 
:ocv:class:`FaceRecognizer` has to overwrite ``FaceRecognizer::load(FileStorage& fs)`` 
to load the model state. ``FaceRecognizer::load(FileStorage& fs)`` in turn gets 
called by ``FaceRecognizer::load(const string& filename)``, to ease saving a 
model.

Eigenfaces
----------

.. ocv:class:: Eigenfaces

Implements the Eigenfaces Method as described in [TP91]_. Only the model-specific 
API is explained. ::

  class Eigenfaces : public FaceRecognizer {

  private:
      int _num_components;
      vector<Mat> _projections;
      vector<int> _labels;
      Mat _eigenvectors;
      Mat _eigenvalues;
      Mat _mean;

  public:
      using FaceRecognizer::save;
      using FaceRecognizer::load;

      // Initializes an empty Eigenfaces model.
      Eigenfaces(int num_components = 0) :
          _num_components(num_components) { }

      // Initializes and computes an Eigenfaces model with images in src and
      // corresponding labels in labels. num_components will be kept for
      // classification.
      Eigenfaces(InputArray src, InputArray labels,
              int num_components = 0) :
          _num_components(num_components) {
          train(src, labels);
      }

      // Computes an Eigenfaces model with images in src and corresponding labels
      // in labels.
      void train(InputArray src, InputArray labels);

      // Predicts the label of a query image in src.
      int predict(const InputArray src) const;

      // See cv::FaceRecognizer::load.
      void load(const FileStorage& fs);

      // See cv::FaceRecognizer::save.
      void save(FileStorage& fs) const;

      // Returns the eigenvectors of this PCA.
      Mat eigenvectors() const { return _eigenvectors; }

      // Returns the eigenvalues of this PCA.
      Mat eigenvalues() const { return _eigenvalues; }

      // Returns the sample mean of this PCA.
      Mat mean() const { return _mean; }

      // Returns the number of components used in this PCA.
      int num_components() const { return _num_components; }
  };
  
Eigenfaces::Eigenfaces(int num_components = 0)
**********************************************

Initializes an Eigenfaces model with a given number of components.

.. ocv:function:: Eigenfaces::Eigenfaces(int num_components = 0)

Initializes an Eigenfaces model with ``num_components``. ``num_components`` 
number of components are kept for classification. If no number of components 
is given (default 0), it is automatically determined from given data in 
:ocv:func:`Eigenfaces::train`.

If (and only if) ``num_components`` <= 0, then ``num_components`` is set to 
(N-1) in ocv:func:`Eigenfaces::train`, with *N* being the total number of 
samples in ``src``.

Eigenfaces::Eigenfaces(InputArray src, InputArray labels, int num_components = 0) 
*********************************************************************************

Initializes and trains an Eigenfaces model with a given number of components 
for given input data and associated labels.

.. ocv:function:: Eigenfaces::Eigenfaces(InputArray src, InputArray labels, int num_components = 0) 

Initializes and trains an Eigenfaces model with images in src and 
corresponding labels in ``labels``. ``num_components`` number of components are 
kept for classification. If no number of components is given (default 0), it is 
automatically determined from given data in :ocv:func:`Eigenfaces::train`.

If (and only if) ``num_components`` <= 0, then ``num_components`` is set to 
(N-1) in ocv:func:`Eigenfaces::train`, with *N* being the total number of 
samples in ``src``.

Eigenfaces::save
*****************
.. ocv:function::  void Eigenfaces::save(FileStorage& fs) const

See :ocv:func:`FaceRecognizer::save`.

Eigenfaces::load
*****************

.. ocv:function:: void Eigenfaces::load(const FileStorage& fs)

See :ocv:func:`FaceRecognizer::load`.

Eigenfaces::train
******************

.. ocv:function:: void Eigenfaces::train(InputArray src, InputArray labels)

See :ocv:func:`FaceRecognizer::train`.

Eigenfaces::predict
********************

.. ocv:function:: int Eigenfaces::predict(InputArray src) const

See :ocv:func:`FaceRecognizer::predict`.

Eigenfaces::eigenvalues
***********************

Returns the eigenvalues corresponding to each of the eigenvectors.

.. ocv:function:: Mat Eigenfaces::eigenvalues() const

Regarding the data alignment, the eigenvalues are stored in a 1D vector as row. 
They are sorted in a descending order.


Eigenfaces::eigenvectors
************************

Returns the eigenvectors of this model.

.. ocv:function:: Mat Eigenfaces::eigenvectors() const

Regarding the data alignment, the i-th eigenvectors is stored in the i-th column 
of this matrix. The eigenvectors are sorted in a descending order by their 
eigenvalue.

Eigenfaces::mean
****************

Returns the sample mean of this model.

.. ocv:function:: Mat Eigenfaces::mean() const

The mean is stored as a 1D vector in a row.

Eigenfaces::num_components
**************************

Returns the number of components (number of Eigenfaces) used for classification.

.. ocv:function:: int Eigenfaces::num_components() const

This number may be 0 for initialized objects. It may be set during the training.

Fisherfaces
-----------

.. ocv:class:: Fisherfaces

Implements the Fisherfaces Method as described in [Belhumeur97]_. Only the 
model-specific API is explained. ::

  // Belhumeur, P. N., Hespanha, J., and Kriegman, D. "Eigenfaces vs. Fisher-
  // faces: Recognition using class specific linear projection.". IEEE
  // Transactions on Pattern Analysis and Machine Intelligence 19, 7 (1997),
  // 711–720.
  class Fisherfaces: public FaceRecognizer {

  private:
      int _num_components;
      Mat _eigenvectors;
      Mat _eigenvalues;
      Mat _mean;
      vector<Mat> _projections;
      vector<int> _labels;

  public:
      using FaceRecognizer::save;
      using FaceRecognizer::load;

      // Initializes an empty Fisherfaces model.
      Fisherfaces(int num_components = 0) :
          _num_components(num_components) {}

      // Initializes and computes a Fisherfaces model with images in src and
      // corresponding labels in labels. num_components will be kept for
      // classification.
      Fisherfaces(InputArray src,
              InputArray labels,
              int num_components = 0) :
          _num_components(num_components) {
          train(src, labels);
      }

      ~Fisherfaces() { }

      // Computes a Fisherfaces model with images in src and corresponding labels
      // in labels.
      void train(InputArray src, InputArray labels);

      // Predicts the label of a query image in src.
      int predict(InputArray src) const;

      // See cv::FaceRecognizer::load.
      virtual void load(const FileStorage& fs);

      // See cv::FaceRecognizer::save.
      virtual void save(FileStorage& fs) const;

      // Returns the eigenvectors of this Fisherfaces model.
      Mat eigenvectors() const { return _eigenvectors; }

      // Returns the eigenvalues of this Fisherfaces model.
      Mat eigenvalues() const { return _eigenvalues; }

      // Returns the sample mean of this Fisherfaces model.
      Mat mean() const { return _eigenvalues; }

      // Returns the number of components used in this Fisherfaces model.
      int num_components() const { return _num_components; }
  };  

Fisherfaces::Fisherfaces(int num_components = 0)
************************************************

Initializes a Fisherfaces model with a given number of components.

.. ocv:function:: Fisherfaces::Fisherfaces(int num_components = 0) 

Initializes a Fisherfaces model with ``num_components``. ``num_components`` 
number of components are  kept for classification. If no number of components 
is given (default 0), it is automatically determined from given data 
in :ocv:func:`Fisherfaces::train`.

If (and only if) ``num_components`` <= 0, then ``num_components`` is set to 
(C-1) in ocv:func:`Fisherfaces::train`, with *C* being the number of unique 
classes in ``labels``.

Fisherfaces::Fisherfaces(InputArray src, InputArray labels, int num_components = 0)
***********************************************************************************

Initializes and trains a Fisherfaces model with a given number of components 
for given input data and associated labels.

.. ocv:function:: Fisherfaces::Fisherfaces(InputArray src, InputArray labels, int num_components = 0) 

Initializes and trains a Fisherfaces model with images in src and 
corresponding labels in ``labels``. ``num_components`` number of components are 
kept for classification. If no number of components is given (default 0), it
is automatically determined from given data in :ocv:func:`Fisherfaces::train`.

If (and only if) ``num_components`` <= 0, then ``num_components`` is set to 
(C-1) in ocv:func:`train`, with *C* being the number of unique classes in 
``labels``.

Fisherfaces::save
*****************
.. ocv:function::  void Fisherfaces::save(FileStorage& fs) const

See :ocv:func:`FaceRecognizer::save`.

Fisherfaces::load
*****************

.. ocv:function:: void Fisherfaces::load(const FileStorage& fs)

See :ocv:func:`FaceRecognizer::load`.

Fisherfaces::train
******************

.. ocv:function:: void Fisherfaces::train(InputArray src, InputArray labels)

See :ocv:func:`FaceRecognizer::train`.

Fisherfaces::predict
********************

.. ocv:function:: int Fisherfaces::predict(InputArray src) const

See :ocv:func:`FaceRecognizer::predict`.

Fisherfaces::eigenvalues
************************

.. ocv:function:: Mat Fisherfaces::eigenvalues() const

See :ocv:func:`Eigenfaces::eigenvalues`.

Fisherfaces::eigenvectors
*************************

.. ocv:function:: Mat Fisherfaces::eigenvectors() const

See :ocv:func:`Eigenfaces::eigenvectors`.

Fisherfaces::mean
*****************

.. ocv:function:: Mat Fisherfaces::mean() const

See :ocv:func:`Eigenfaces::mean`.

Fisherfaces::num_components
***************************

.. ocv:function:: int Fisherfaces::num_components() const

See :ocv:func:`Eigenfaces::num_components`.


Fisherfaces
-----------

.. ocv:class:: LBPH

Implements the Local Binary Patterns Histograms as described in [Ahonen04]_. 
Only the model-specific API is explained. ::

  //  Ahonen T, Hadid A. and Pietikäinen M. "Face description with local binary
  //  patterns: Application to face recognition." IEEE Transactions on Pattern
  //  Analysis and Machine Intelligence, 28(12):2037-2041.
  //
  class LBPH : public FaceRecognizer {

  private:
      int _grid_x;
      int _grid_y;
      int _radius;
      int _neighbors;

      vector<Mat> _histograms;
      vector<int> _labels;

  public:
      using FaceRecognizer::save;
      using FaceRecognizer::load;

      // Initializes this LBPH Model. The current implementation is rather fixed
      // as it uses the Extended Local Binary Patterns per default.
      //
      // radius, neighbors are used in the local binary patterns creation.
      // grid_x, grid_y control the grid size of the spatial histograms.
      LBPH(int radius=1, int neighbors=8, int grid_x=8, int grid_y=8) :
          _grid_x(grid_x),
          _grid_y(grid_y),
          _radius(radius),
          _neighbors(neighbors) {}

      // Initializes and computes this LBPH Model. The current implementation is
      // rather fixed as it uses the Extended Local Binary Patterns per default.
      //
      // (radius=1), (neighbors=8) are used in the local binary patterns creation.
      // (grid_x=8), (grid_y=8) controls the grid size of the spatial histograms.
      LBPH(InputArray src,
              InputArray labels,
              int radius=1, int neighbors=8,
              int grid_x=8, int grid_y=8) :
                  _grid_x(grid_x),
                  _grid_y(grid_y),
                  _radius(radius),
                  _neighbors(neighbors) {
          train(src, labels);
      }

      ~LBPH() { }

      // Computes a LBPH model with images in src and
      // corresponding labels in labels.
      void train(InputArray src, InputArray labels);

      // Predicts the label of a query image in src.
      int predict(InputArray src) const;

      // See cv::FaceRecognizer::load.
      void load(const FileStorage& fs);

      // See cv::FaceRecognizer::save.
      void save(FileStorage& fs) const;

      // Getter functions.
      int neighbors() const { return _neighbors; }
      int radius() const { return _radius; }
      int grid_x() const { return _grid_x; }
      int grid_y() const { return _grid_y; }

  };

LBPH::LBPH(int radius=1, int neighbors=8, int grid_x=8, int grid_y=8)
*********************************************************************


LBPH::LBPH(InputArray src, InputArray labels, int radius=1, int neighbors=8, int grid_x=8, int grid_y=8)
********************************************************************************************************

LBPH::save
**********

See :ocv:func:`FaceRecognizer::save`.

LBPH::load
**********

See :ocv:func:`FaceRecognizer::load`.

LBPH::train
***********

.. ocv:function:: void train(InputArray src, InputArray labels)

See :ocv:func:`FaceRecognizer::train`.

LBPH::predict
*************

.. ocv:function:: int predict(InputArray src) const

See :ocv:func:`FaceRecognizer::predict`.

LBPH::neighbors
***************

.. ocv:function:: int LBPH::neighbors() const

LBPH::radius
************

.. ocv:function:: int LBPH::radius() const

LBPH::grid_x
************

.. ocv:function:: int LBPH::grid_x() const

LBPH::grid_y
************

.. ocv:function:: int LBPH::grid_y() const
